<?php

namespace Controllers\Repo\Package;

use \Controllers\Filesystem\File;
use \Controllers\Filesystem\Directory;
use \Controllers\Process;
use Exception;

trait Sign
{
    /**
     *  Sign the packages with GPG (RPM only)
     *  Exclusive to rpm packages because with deb it's the Release file that is signed
     */
    private function signPackage()
    {
        $workingDir = REPOS_DIR . '/temporary-task-' . $this->taskId;

        /**
         *  Skip if not rpm
         */
        if ($this->repoController->getPackageType() != 'rpm') {
            return;
        }

        /**
         *  Skip if package signing is not enabled
         */
        if ($this->repoController->getGpgSign() != 'true') {
            return;
        }

        // If action is 'rebuild', set working dir to the existing snapshot path
        if ($this->action == 'rebuild') {
            $workingDir = REPOS_DIR . '/rpm/' . $this->repoController->getName() . '/' . $this->repoController->getReleasever() . '/' . $this->repoController->getDate();
        }

        /**
         *  Signing packages with GPG
         */
        $this->taskLogStepController->new('sign-packages', 'SIGNING PACKAGES');
        $this->taskLogSubStepController->new('sign-packages', 'SIGNING PACKAGES WITH GPG');

        /**
         *  In case of a new repository or a repository rebuild, all packages must be signed
         *  Force all packages to be signed
         */
        if ($this->action == 'create' or $this->action == 'rebuild') {
            $this->packagesToSign = 'all';
        }

        /**
         *  In case of a repository update, we need to check if the previous repo snapshot was signed
         *  If the previous repo snapshot was not signed at all and the new one has to be signed, then force all packages to be signed
         */
        if ($this->action == 'update') {
            if ($this->sourceRepoController->getSigned() == 'false' and $this->repoController->getGpgSign() == 'true') {
                $this->packagesToSign = 'all';
            }
        }

        /**
         *  If all packages must be signed, retrieve all RPM files recursively
         */
        if (!is_array($this->packagesToSign) and $this->packagesToSign == 'all') {
            $rpmFiles = File::findRecursive($workingDir . '/packages', ['rpm'], true);
        }

        /**
         *  Else, if only specific packages must be signed ($this->packagesToSign is an array with a list of packages), retrieve the list of packages to sign
         *  This list was generated by the rpm mirroring task (see Rpm.php)
         *  The list is a list of relative paths to the packages, so we need to add the full path to the packages
         */
        if (is_array($this->packagesToSign)) {
            foreach ($this->packagesToSign as $relativePackagePath) {
                $rpmFiles[] = $workingDir . '/' . $relativePackagePath;
            }
        }

        /**
         *  If no packages are found or no packages were marked for signing, print a message and nothing will be signed
         */
        if (empty($rpmFiles)) {
            $this->taskLogSubStepController->output('No packages marked for signing.');
        }

        /**
         *  Otherwise, sort all files by name
         */
        if (!empty($rpmFiles)) {
            asort($rpmFiles);

            /**
             *  Count total packages to sign and initialize counter
             */
            $totalPackages = count($rpmFiles);
            $packageCounter = 0;

            /**
             *  Print if all packages are to be signed or if specific packages are to be signed
             */
            if (!is_array($this->packagesToSign) and $this->packagesToSign == 'all') {
                $this->taskLogSubStepController->output('Signing all packages');
            }
            if (is_array($this->packagesToSign)) {
                $this->taskLogSubStepController->output('Signing ' . $totalPackages . ' package(s)');
            }

            /**
             *  Process each found file
             */
            foreach ($rpmFiles as $rpmFile) {
                $packageCounter++;

                /**
                 *  We need a gpg macros file, we sign only if the macros file is present, otherwise we return an error
                 */
                if (!file_exists(MACROS_FILE)) {
                    throw new Exception('GPG macros file for rpm does not exist.');
                }

                if (!file_exists($rpmFile)) {
                    throw new Exception('RPM file <code>' . $rpmFile . '</code> not found (deleted?).');
                }

                /**
                 *  Print package counter
                 */
                $this->taskLogSubStepController->new('signing-package-' . $packageCounter, 'SIGNING PACKAGE (' . $packageCounter . '/' . $totalPackages . ')', basename($rpmFile));

                // If a .signed file exists for this package, it means it has already been signed, so we skip it
                if (file_exists($rpmFile . '.signed')) {
                    $this->taskLogSubStepController->completed('Already signed (resuming from previous run)');
                    continue;
                }

                /**
                 *  Sign package
                 */
                $myprocess = new Process('/usr/bin/rpmsign --macros=' . MACROS_FILE . ' --addsign ' . $rpmFile, array('GPG_TTY' => '$(tty)'));

                /**
                 *  Execution
                 */
                $myprocess->execute();

                /**
                 *  Retrieve output from process
                 */
                $output = $myprocess->getOutput();

                $myprocess->close();

                /**
                 *  If the signature of the current package fails
                 */
                if ($myprocess->getExitCode() != 0) {
                    // If the RPM_SIGNATURE_FAIL setting is set to 'error', then stop the task with an error
                    if (RPM_SIGNATURE_FAIL == 'error') {
                        // First, delete everything to avoid leaving a broken repository (don't delete if the action is 'rebuild')
                        // if ($this->action != 'rebuild') {
                        //     Directory::deleteRecursive(REPOS_DIR . '/rpm/' . $this->repoController->getName() . '/' . $this->repoController->getReleasever() . '/' . $this->repoController->getDate());
                        // }

                        throw new Exception('Error while signing package<br><pre class="codeblock margin-top-10">' . $output . '</pre>');
                    }

                    // If the RPM_SIGNATURE_FAIL setting is set to 'keep', then we keep the package and continue
                    if (RPM_SIGNATURE_FAIL == 'keep') {
                        $this->taskLogSubStepController->warning('Package signature failed (package kept anyway)');
                        $this->taskLogSubStepController->output($output, 'pre');

                        continue;
                    }

                    // If the RPM_SIGNATURE_FAIL setting is set to 'ignore', then we ignore the package (delete it) and continue
                    if (RPM_SIGNATURE_FAIL == 'ignore') {
                        $this->taskLogSubStepController->warning('Package signature failed, ignoring package (deleting it) and continuing');

                        // Delete the package
                        if (file_exists($rpmFile)) {
                            unlink($rpmFile);
                        }

                        $this->taskLogSubStepController->output($output, 'pre');

                        continue;
                    }
                }

                /**
                 *  Specific case, we will display a warning if "warning:" has been detected in the logs
                 */
                if (preg_match("/warning:/i", $output)) {
                    // If the warning is about an identical signature, we skip the package and mark the substep as completed
                    if (preg_match("/already contains identical signature, skipping/", $output)) {
                        $this->taskLogSubStepController->completed('Identical signature already present, skipping');

                    // Otherwise, we display the warning and mark the substep as completed
                    } else {
                        $this->taskLogSubStepController->warning('Warning detected during package signing');
                        $this->taskLogSubStepController->output($output, 'pre');
                    }
                } else {
                    $this->taskLogSubStepController->completed();
                }

                // Create .signed file to indicate that signing is complete
                $this->createSignedFile($rpmFile);
            }
        }

        // Set the main substep as completed
        $this->taskLogSubStepController->completed('', 'sign-packages');

        $this->taskLogStepController->completed();
    }

    /**
     *  Create .signed file to indicate that signing is complete
     */
    private function createSignedFile(string $path) : void
    {
        if (!touch($path . '.signed')) {
            throw new Exception('Cannot create .signed file for ' . $path);
        }
    }
}
