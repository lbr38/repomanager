#!/bin/bash
set -u
export LC_ALL="fr_FR.UTF-8" # Afin que crontab exécute ce script avec des locales en français
export TERM="xterm-256color"
export COLUMNS=190
export GPG_TTY=$(tty)


## ↓ VARIABLES ↓ ##
# Import de toutes les variables nécéssaires au script
if [ -f "/etc/repomanager/vars/customs.vars" ];then
	source "/etc/repomanager/vars/customs.vars"
else
	echo "Erreur : impossible de trouver le fichier de variables customs.vars"
	exit
fi

if [ -f "/etc/repomanager/vars/main.vars" ];then
	source "/etc/repomanager/vars/main.vars"
else
	echo "Erreur : impossible de trouver le fichier de variables main.vars"
	exit
fi

# Si on ne connait pas l'OS ni sa version, on quitte
if [ -z "$OS_FAMILY" ];then
	echo -e "[$JAUNE ERREUR ${RESET}] L'OS de cette machine n'a pas été reconnu (Debian, Redhat...)"
	exit
fi
if [ -z "$OS_VERSION" ];then
	echo -e "[${ROUGE} ERREUR ${RESET}] La version d'OS n'est pas connue (vide)"
	exit
fi


## ↓ FONCTIONS ↓ ##

print_help() { 
SEP
echo -e "\n
${JAUNE}Toutes les opérations s'effectuent depuis l'interface web.${RESET}
\n
Paramètres disponibles en ligne de commande :
  --repo, --list-repos, -r                  ➤  Afficher la liste des repos actifs
  --archrepo, --list-archived-repos, -ar    ➤  Afficher la liste des repos archivés
  --check, -c                               ➤  Vérification des fichiers de conf du script
\n"
SEP
}

nettoyage_fichier_conf() {    # Retire les commentaires et les lignes vides du fichier passé en paramètre et le renvoi dans le fichier $CONF_NETTOYEE
CONF_NETTOYEE="/tmp/repomanager_conf_clean.txt"                 	# Ce fichier est destiné à récupérer le contenu du fichier de conf sans les commentaires ni espaces blancs
echo -n> "$CONF_NETTOYEE"
sed "/^[ \t]*#.*/d" $CONF | sed "/^[ \t]*$/d" > "$CONF_NETTOYEE"    # Suppression des commentaires et espaces blancs du fichier de liste passé en argument
CONF="$CONF_NETTOYEE"                                               # La variable $CONF devient le fichier de liste nettoyé précedemment
}

install() { 
	source "${FUNCTIONS}/00_install"
}

checkDependencies() { 
	source "${FUNCTIONS}/00_checkDependencies"
}

# Vérifiction de la conf repomanager.conf
checkConf() { 
	source "${FUNCTIONS}/00_checkConf"
}

# Récupération de la conf repomanager.conf
getConf() {
	source "${FUNCTIONS}/00_getConf"
}

execPlan() {
	source "${FUNCTIONS}/20_planifications"
	execute $PLAN_ID
}

planReminders() {
	source "${FUNCTIONS}/20_planifications"
	sendReminders
}

listRepo() {
	source "${FUNCTIONS}/98_listRepo"
}

listOldRepo() {
	source "${FUNCTIONS}/98_listOldRepo"
}

espace_disque() {
echo -ne "\nEspace restant sur le serveur : "
ESPACE_DISQUE=$(df | egrep "/$" | awk '{print $4}')   # Affichage de l'espace restant sur /home
if [ $ESPACE_DISQUE -lt 50000000 ];then
    echo -ne "${ROUGE}"
    df -h | egrep "/$" | awk '{print $4}'
    echo -ne "${RESET}"
elif [ $ESPACE_DISQUE -lt 100000000 ];then
    echo -ne "${JAUNE}"
    df -h | egrep "/$" | awk '{print $4}'
    echo -ne "${RESET}"
else
    df -h | egrep "/$" | awk '{print $4}'
fi

echo ""
}

newRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/01_newRepo-rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/01_newRepo-deb";fi
}

updateRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/02_updateRepo-rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/02_updateRepo-deb";fi
}

duplicateRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/03_duplicateRepo-rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/03_duplicateRepo-deb";fi
}

changeEnv() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/03_changeEnv-rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/03_changeEnv-deb";fi
}

# only for Debian
deleteSection() { 
	source "${FUNCTIONS}/04_deleteSection"
}

# only for Debian
deleteDist() { 
	source "${FUNCTIONS}/05_deleteDist" 
}

deleteRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/06_deleteRepo_rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/06_deleteRepo_deb";fi
}

deleteOldRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/07_deleteOldRepo_rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/07_deleteOldRepo_deb";fi
}

restoreOldRepo() {
	if [ "$OS_FAMILY" == "Redhat" ];then source "${FUNCTIONS}/08_restoreOldRepo_rpm";fi
	if [ "$OS_FAMILY" == "Debian" ];then source "${FUNCTIONS}/08_restoreOldRepo_deb";fi
}

generateConf() {
	source "${FUNCTIONS}/09_generateConf"
}

deleteConf() {
	source "${FUNCTIONS}/09_deleteConf"
}

sortLists() {
	source "${FUNCTIONS}/98_sortLists"
}

update() {
	source "${FUNCTIONS}/99_update"
}

permissions() {
	source "${FUNCTIONS}/100_permissions"
}

cronjob_daily() {
	source "${FUNCTIONS}/30_cronjob_daily"
}

# à vérifier
rapport_mail() {
# Avant toute chose, on supprime les codes couleurs ANSI dans le fichier de log, ils sont utiles pour afficher de la couleur dans le terminal mais ils polluent le rapport mail qui devient illisible :
sed 's/\x1b\[[0-9;]*m//g' "$LOG" > "$LOG_PARSED"

# Si l'une de ces 3 variables n'est pas vide, c'est qu'il y a eu des erreurs, on envoie donc un mail avec un titre d'erreur
if [ ! -z "$MSG_MAIN_ERROR" ] || [ ! -z "$MSG_CHECK_CONF_ERROR" ] || [ ! -z "$MSG_PLAN_ERROR" ];then
	# Cas où il s'agit d'une planification
	if [ "$PLAN_EXEC" -eq "1" ];then
		echo -e "$MSG_MAIN" | mutt -s "[ERREUR] Planification [Plan-${PLAN_ID}] sur ${HOSTNAME}" -a $LOG_PARSED -- $EMAIL_DEST
	fi
	# Autres cas
	# if [ "$XXXXX" -eq "1" ];then
	#
fi
}


rappel_mail() {
# Messages de rappels de planification
if [ ! -z "$MSG_REMINDER" ];then
	MSG_REMINDER="${MSG_REMINDER}\nCeci est un rappel automatique des planifications à venir :\n${MSG_REMINDER}\n\nVous pouvez à tout moment annuler une planification depuis l'onglet Planifications"
	echo -e "$MSG_REMINDER" | mutt -s "[RAPPEL] Tâche(s) automatique(s) planifiée(s) sur ${WWW_HOSTNAME}" $EMAIL_DEST
fi
}

clean_exit() {
# Retour au répertoire de base, pour ne pas empêcher un quelconque nettoyage de répertoire
cd "$BASE_DIR"

# En mode auto (planification), on concatene tous les messages d'erreurs rencontrés dans 1 message global afin de l'envoyer par mail :
if [ "$TTY" -eq "0" ];then
	# On commence par les messages d'erreur de conf
	if [ ! -z "$MSG_CHECK_CONF_ERROR" ];then
		MSG_MAIN="${MSG_MAIN}\nErreur lors de la vérification de la configuration :\n${MSG_CHECK_CONF_ERROR}"
	fi

	if [ ! -z "$MSG_MAIN_ERROR" ];then
		MSG_MAIN="${MSG_MAIN}\nErreur lors du traitement :\n${MSG_MAIN_ERROR}"
	fi

	# Messages d'erreur des planifications
	if [ ! -z "$MSG_PLAN_ERROR" ];then
		MSG_MAIN="${MSG_MAIN}\nErreur lors du traitement de la planification :\n${MSG_PLAN_ERROR}"
	fi

	# On ajoute aussi les messages de repos supprimés même si ce n'est pas une erreur
	if [ ! -z "$MSG_INFO_SUPPR_AUTO" ];then
        MSG_MAIN="${MSG_MAIN}\n Anciens repos supprimés :\n${MSG_INFO_SUPPR_AUTO}"
	fi

	# Du coup si on a un message global, on l'affiche à l'écran pour qu'il soit affiché dans le log et on envoie un mail
	if [ ! -z "$MSG_MAIN" ];then
		echo -e "$MSG_MAIN"
		rapport_mail
	fi	
fi

# On tri le contenu des fichiers de listes
sortLists

# On réapplique les droits afin qu'ils soient d'aplomb pour la prochaine exécution
permissions

# Suppression des fichiers temporaires utilisés pendant l'opération
rm /tmp/repomanager* -fr

# Suppression du script d'installation
rm "${BASE_DIR}"/install -f

# Suppression du répertoire de mise à jour si une mise à jour a eu lieu
rm "${BASE_DIR}"/update -fr

# Suppression des fichiers ignore si il y en a
rm "${BASE_DIR}"/.*ignore -fr

exit
}


## TRAITEMENT ##

# Pré-lecture des paramètres, initialisation de variables supplémentaires
if [ $# -ge "1" ];then
	case "$1" in
		--cronjob-daily)
			TTY="0"
			checkConf
			getConf
			cronjob_daily
			clean_exit
		;;
		--exec-plan)
			TTY="0"
			PLAN_EXEC=1
			PLAN_ID=$2
		;;
	esac
fi

# Crée les répertoire de base si n'existent pas
mkdir -p "${BASE_DIR}"
mkdir -p "${REPOS_DIR}"

# Création du répertoire de logs si n'existe pas
mkdir -p "${MAIN_LOGS_DIR}/"

# Vidage des fichiers de logs
	echo -n> "$LOG"
	chmod 660 "$LOG"

# On écrit tout ce qu'il se passe dans le fichier de log principal
exec &> >(tee -a "$LOG")

# On récupère les infos sur la précédente exécution du script dans le fichier de log précédent
if [ -f "${MAIN_LOGS_DIR}/lastlog.log" ];then
	LAST_EXECUTION_DATE=$(readlink -f ${MAIN_LOGS_DIR}/lastlog.log | awk -F '/' '{print $NF}' | awk -F '_' '{print $2}')
	LAST_EXECUTION_DATE=$(date -d"$LAST_EXECUTION_DATE" +%d-%m-%Y)
	LAST_EXECUTION_TIME=$(readlink -f ${MAIN_LOGS_DIR}/lastlog.log | awk -F '/' '{print $NF}' | awk -F '_' '{print $3}' | sed 's/.log//g' | sed 's/-/:/g')
	LAST_EXECUTION_TIME=$(date -d"$LAST_EXECUTION_TIME" +%Hh%M:%Ss)
	LAST_EXECUTION_USER="$(cat ${MAIN_LOGS_DIR}/lastlog.log | grep 'Exécuté par' | sed 's/.*: //g')"
	LAST_EXECUTION_MESSAGE="Le ${LAST_EXECUTION_DATE} à ${LAST_EXECUTION_TIME} (${LAST_EXECUTION_USER})"
else
	LAST_EXECUTION_MESSAGE="N/A"
fi

# Puis on recrée un lien symbolique 'lastlog.log' pointant vers le fichier de log en cours
if [ -f "${MAIN_LOGS_DIR}/lastlog.log" ];then unlink "${MAIN_LOGS_DIR}/lastlog.log";fi
ln -sf "$LOG" "${MAIN_LOGS_DIR}/lastlog.log"

# Affichage du logo ASCI repomanager
cat "${FUNCTIONS}/logo"                                                            

# Affichage de la version en cours et vérification de la disponibilité d'une nouvelle version sur github
printf "%-30s %s" "   ${JAUNE}Version" "${RESET}: $VERSION "

if [ -f "${BASE_DIR}/cron/github.version" ];then
	GITHUB_VERSION=$(grep '^GITHUB_VERSION=' ${BASE_DIR}/cron/github.version | awk -F= '{print $2}' | sed 's/"//g')
fi
if [ -z "$GITHUB_VERSION" ];then
    echo ""
# Compare la version de github avec la version actuelle :
elif [ "$VERSION" != "$GITHUB_VERSION" ];then
	UPDATE_AVAILABLE="1"
    echo -e "(${JAUNE}nouvelle version disponible sur github${RESET})"
else # Si il n'y a pas de mise à jour, on n'affiche rien, mais on saute une ligne
    echo ""
fi

if [ "$OS_FAMILY" == "Redhat" ];then
	printf "%-30s %s\n" "   ${JAUNE}OS" "${RESET}: Redhat/CentOS"
	printf "%-30s %s\n" "   ${JAUNE}Paquets gérés" "  ${RESET}: rpm"
fi

if [ "$OS_FAMILY" == "Debian" ];then
	printf "%-30s %s\n" "   ${JAUNE}OS" "${RESET}: Debian"
	printf "%-30s %s\n" "   ${JAUNE}Paquets gérés" "  ${RESET}: deb"
fi
WHOAMI=$(whoami)
printf "%-30s %s\n" "   ${JAUNE}Exécuté par" "  ${RESET}: $WHOAMI"
printf "%-30s %s\n" "   ${JAUNE}Dernière exécution" "  ${RESET}: $LAST_EXECUTION_MESSAGE"
echo -e "\n\n"

# On vérifie la conf générale de repomanager.conf ainsi que la cohérence des infos dans les fichiers repos.list et repo_spec.conf avant de commencer
checkConf
# Récupération de la conf si celle-ci a été validée par checkConf
getConf

permissions

# Si la mise à jour automatique est activée et qu'une mise à jour est disponible (testée plus haut), alors on mets à jour repomanager
if [ "$UPDATE_AUTO" == "yes" ] && [ "$UPDATE_AVAILABLE" -eq "1" ];then
	update
fi

# Réinitialisation des variables qui aurait pu être utilisées pour la vérif de la conf
REPO_NAME=""
REPO_REALNAME=""
REPO_HOST=""
REPO_RACINE=""
REPO_DIST=""
REPO_SECTION=""
REPO_ENV=""
REPO_DATE=""
REPO_DESCRIPTION=""

# Si on en est là c'est que les vérifications sont passées (checkConf / getConf) et qu'on peut cette fois relire les paramètres pour lancer les opérations
# Relecture des paramètres et lancement des opérations
while [ $# -ge 1 ];do
	case "$1" in
		--help|-help|-h)
            print_help
            clean_exit
       	;;
		--tty)
			TTY="1"
		;;
		--no-tty|--web)
			TTY="0"
		;;
		--repo|--list-repos|-r)
        	listRepo
	    	clean_exit
    	;;
		--archrepo|--list-archived-repos|-ar)
			listOldRepo
			clean_exit
		;;
		--check|-c) # Vérifie la conf (checkConf ci-dessus) et quittes le script
	    	clean_exit
    	;;
		--planReminders)
			TTY="0"
			planReminders
		;;
		--check-update|-cu)
			checkUpdate
			clean_exit
		;;
		--update|--upgrade|-u)
			update
			clean_exit
		;;
## Paramètres d'opérations ##
		--newRepo)
			shift
			newRepo $*
			clean_exit
		;;
        --updateRepo)
            shift           # on shift pour ne plus inclure --updateRepo parmi les paramètres
    		updateRepo $*   # puis on appelle la fonction updateRepo avec tous les paramètres suivants
			clean_exit
        ;;
        --changeEnv)
            shift
            changeEnv $*
			clean_exit
        ;;
		--duplicateRepo)
			shift
			duplicateRepo $*
			clean_exit
		;;
		--deleteRepo)
			shift
			deleteRepo $*
			clean_exit
		;;
		--deleteDist)
			shift
			deleteDist $*
			clean_exit
		;;
		--deleteSection)
			shift
			deleteSection $*
			clean_exit
		;;
		--restoreOldRepo)
			shift
			restoreOldRepo $*
			clean_exit
		;;
		--deleteOldRepo)
			shift
			deleteOldRepo $*
			clean_exit
		;;
		--reset-install)
			rm "$CONF" -f
			install
		;;
		--install)
			install
		;;
		--droits)
			permissions
		;;
		--exec-plan)
			execPlan "$PLAN_ID"
		;;
# anciens paramètres (à vérifier)
        --suppr-auto)
            SUPPR_AUTO=1
        ;;
       	*)
       	echo "Unknown argument: $1"
       	print_help
        clean_exit
       	;;
    esac
	shift
done

# pour le moment ne pas s'occuper de ces deux options automatiques :
#
#if [ "$SUPPR_AUTO" -eq "1" ];then
	#traitement_nettoyage
#fi

clean_exit