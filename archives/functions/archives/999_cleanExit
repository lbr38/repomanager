#!/bin/bash
# Nettoyage, envoi des mails éventuels avant de quitter le programme

# Retour au répertoire de base, pour ne pas empêcher un quelconque nettoyage de répertoire
#cd "$BASE_DIR"

# En mode auto (planification), on concatene tous les messages d'erreurs rencontrés dans 1 message global afin de l'envoyer par mail :
#if [ "$TTY" -eq "0" ];then
#	# On commence par les messages d'erreur de conf
#	if [ ! -z "$MSG_CHECK_CONF_ERROR" ];then
#		MSG_MAIN="${MSG_MAIN}\nErreur lors de la vérification de la configuration :\n${MSG_CHECK_CONF_ERROR}"
#	fi
#
#	# Messages d'erreur lors du traitement d'une opération
#	if [ ! -z "$MSG_MAIN_ERROR" ];then
#		MSG_MAIN="${MSG_MAIN}\nErreur lors du traitement :\n${MSG_MAIN_ERROR}"
#	fi
#
#	# Messages d'erreur des planifications
#	if [ ! -z "$MSG_PLAN_ERROR" ];then
#		MSG_MAIN="${MSG_MAIN}\nErreur lors du traitement de la planification :\n${MSG_PLAN_ERROR}"
#	fi

#	# Si des anciens repos ont été supprimés, on envoi un mail
#	if [ ! -z "$MSG_DELETE_ARCHIVED_REPOS_AUTO" ];then
#		sendMail
#	fi
#
#	# Du coup si on a un message global, on l'affiche à l'écran pour qu'il soit affiché dans le log et on envoie un mail
#	if [ ! -z "$MSG_MAIN" ];then
#		sendMail
#	fi
#fi

# On réapplique les droits afin qu'ils soient d'aplomb pour la prochaine exécution
#permissions

# Suppression du script d'installation
rm "${BASE_DIR}"/install -f

# Suppression du répertoire de mise à jour si une mise à jour a eu lieu
rm "${BASE_DIR}"/update -fr

# Suppression des fichiers ignore si il y en a
rm "${BASE_DIR}"/.*ignore -fr

# On supprime le fichier de log si KEEP_LOG != yes
if [ "$KEEP_LOG" != "yes" ];then
	rm "$LOG" -f
fi

# Suppression des fichiers temporaires utilisés pendant l'opération
rm /tmp/repomanager* -fr

exit