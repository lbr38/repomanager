#!/bin/bash

echo -ne "   Vérification des fichiers de conf : "
### 1 ###

# Si le fichier de planifications n'existe pas, on le crée
if [ ! -f "$PLAN_CONF" ];then echo -e "[PLANIFICATIONS]\n\n" > "$PLAN_CONF";fi

# Si le fichier de groupes n'existe pas, on le crée
if [ ! -f "$GROUPS_CONF" ];then echo -e "[GROUPES]\n\n" > "$GROUPS_CONF";fi

# Si le fichier d'envs n'existe pas, on le crée
if [ ! -f "$ENV_CONF" ];then touch "$ENV_CONF";fi

# Si les fichiers de listes repos n'existent pas on les crée
if [ ! -f "$REPOS_LIST" ];then touch "$REPOS_LIST";fi
if [ ! -f "$REPOS_ARCHIVE_LIST" ];then touch "$REPOS_ARCHIVE_LIST";fi
if [ ! -f "$HOSTS_CONF" ] && [ "$OS_FAMILY" == "Debian" ];then touch "$HOSTS_CONF";fi

# Création du répertoire contenant les fichiers de conf repos si n'existe pas
if [ ! -d "$REPOS_CONF_FILES_DIR" ];then
	mkdir -p "$REPOS_CONF_FILES_DIR"
fi

# Création des répertoires de logs si n'existent pas
mkdir -p "$LOGS_DIR"
mkdir -p "$MAIN_LOGS_DIR"
mkdir -p "$PLAN_LOGS_DIR"
mkdir -p "$CRON_LOGS_DIR"


# Vérification de la présence du fichier de conf repomanager.conf :
# Si le fichier de conf n'existe pas ou est vide :
if [ ! -f "$CONF" ] || [ ! -s "$CONF" ];then
	if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLe fichier de conf repomanager.conf n'existe pas ou est vide. Il faut lancer repomanager manuellement pour le créer et le configurer" &&
	    (( CHECK_CONF_ERROR++ ))
    fi
    if [ "$TTY" -eq "1" ];then
	    # Si le script est lancé en mode manuel, on va vérifier que les dépendances sont installées, puis on va créer le fichier et demander les infos à l'utilisateur (fonction générate_conf)
		echo -e "\n[$JAUNE WARNING $RESET] Aucun fichier de conf repomanager.conf n'a été trouvé pour ce script.\nCela semble une première installation de repomanager, les dépendances vont être vérifiées et le fichier de conf sera généré."
		echo -ne "➤ Continuer (y/n) : "; read -p "" CONFIRM
		if [ "$CONFIRM" != "y" ];then
			clean_exit
		fi
		checkDependencies
		install
	fi
fi


#### Vérification de la présence de tous les paramètres dans le fichier de conf ####

### 2 ###
# Cas où le fichier de conf existe mais que la variable EMAIL_DEST n'est pas renseignée 
if [ -z "$(grep "^EMAIL_DEST=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')" ];then
    if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
        MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'EMAIL_DEST' n'est pas renseignée dans le fichier de conf repomanager.conf."
        (( CHECK_CONF_ERROR++ ))
    else # Si on est en mode manuel, on demande l'info à l'utilisateur
        echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
        install
    fi
fi

# Cas où le fichier de conf existe mais que la variable MANAGE_PROFILES n'est pas renseignée 
if [ -z $(grep "^MANAGE_PROFILES=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
    if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
        MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'MANAGE_PROFILES' n'est pas renseignée dans le fichier de conf repomanager.conf."
        (( CHECK_CONF_ERROR++ ))
    else # Si on est en mode manuel, on demande l'info à l'utilisateur
        echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
        install
    fi
fi

# Cas où le fichier de conf existe mais que la variable REPO_CONF_FILES_PREFIX n'existe pas (elle peut être vide cependant) 
if ! grep -q "^REPO_CONF_FILES_PREFIX=" "$CONF";then
    if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
        MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'REPO_CONF_FILES_PREFIX' n'est pas renseignée dans le fichier de conf repomanager.conf."
        (( CHECK_CONF_ERROR++ ))
    else # Si on est en mode manuel, on demande l'info à l'utilisateur
        echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
        install
    fi
fi

# Cas où le fichier de conf existe mais que la variable RELEASEVER n'est pas renseignée (on ne fait pas cette étape pour Debian)
if [ "$OS_FAMILY" == "Redhat" ];then
	if [ -z $(grep "^RELEASEVER=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
    	if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
        	MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'RELEASEVER' n'est pas renseignée dans le fichier de conf repomanager.conf."
        	(( CHECK_CONF_ERROR++ ))
    	else	# Si on est en mode manuel, on demande l'info à l'utilisateur
        	echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
            install
    	fi
	fi

	# Cas où le fichier de conf existe mais que la variable GPG_SIGN_PACKAGES n'est pas renseignée (on ne fait pas cette étape pour Debian)
	if [ -z $(grep "^GPG_SIGN_PACKAGES=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
		if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
			MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'GPG_SIGN_PACKAGES' n'est pas renseignée dans le fichier de conf repomanager.conf."
			(( CHECK_CONF_ERROR++ ))
		else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
			echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
			install
		fi
	else # On récupère la valeur de GPG_SIGN_PACKAGES car on va en avoir besoin pour vérifier la condition suivante
		GPG_SIGN_PACKAGES=$(grep "^GPG_SIGN_PACKAGES=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')
	fi

    if [ "$GPG_SIGN_PACKAGES" == "yes" ];then
		# Cas où la signature des paquet est activée mais que le répertoire .gnupg/ est vide ou n'existe pas
		# Si n'existe pas on le créé
		mkdir -p "${GPGHOME}"
		# Si le répertoire est vide alors on va demander à générer une clé gpg
		if [ -z "$(ls -A ${GPGHOME}/)" ];then
			if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
				MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLe répertoire .gnupg contenant la clé GPG de signature des paquets semble vide."
				(( CHECK_CONF_ERROR++ ))
			else
				echo -e "[$JAUNE WARNING $RESET] Configuration de repomanager incomplète (répertoire .gnupg vide)..."
				install
			fi
		fi

		# Cas où le répertoire .gnupg existe mais qu'il n'y a pas de trousseau
		if [ ! -f "${GPGHOME}/pubring.kbx" ] && [ ! -f "${GPGHOME}/pubring.gpg" ];then # Si le trousseau pubring (.kbx ou .gpg selon la version) n'existe pas
			if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
				MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nIl ne semble pas y avoir de trousseau de clé GPG pour la signature des paquets."
				(( CHECK_CONF_ERROR++ ))
			else
				echo -e "[$JAUNE WARNING $RESET] Configuration de repomanager incomplète (trousseau pubring absent)..."
				install
			fi
		fi 

		# Cas où le répetoire .gnupg existe mais qu'il n'y a aucune clé dans le trousseau
		LISTKEYS=$(gpg2 --homedir ${GPGHOME} --no-permission-warning --list-key)
		if [ -z "$LISTKEYS" ];then
			if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
				MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nIl ne semble pas y avoir de clé GPG pour la signature des paquets."
				(( CHECK_CONF_ERROR++ ))
			else
				echo -e "[$JAUNE WARNING $RESET] Configuration de repomanager incomplète (aucune clé gpg n'est présente dans le trousseau)..."
				install
			fi
		fi	

        # Cas où le fichier de conf existe mais que la variable GPG_KEYID n'est pas renseignée (on ne fait pas cette étape pour Debian)
        if [ -z $(grep "^GPG_KEYID=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
            if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
                MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'GPG_KEYID' n'est pas renseignée dans le fichier de conf repomanager.conf."
                (( CHECK_CONF_ERROR++ ))
            else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
                echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
                install
            fi
		else # On récupère la valeur de GPG_KEYID car on va en avoir besoin pour vérifier la passphrase
			GPG_KEYID=$(grep "^GPG_KEYID=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')
        fi
    fi
fi


# Cas où le fichier de conf existe ; on récupère les informations concernant la mise à jour automatique de repomanager
if [ -z $(grep "^UPDATE_AUTO=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ] ;then
	if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'UPDATE_AUTO' n'est pas renseignée dans le fichier de conf repomanager.conf."
		(( CHECK_CONF_ERROR++ ))
	else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
		echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
		install
	fi
else # On récupère la valeur de UPDATE_AUTO car on va en avoir besoin pour vérifier la condition suivante
	UPDATE_AUTO=$(grep "^UPDATE_AUTO=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')
fi

# Cas où le fichier de conf existe ; on récupère les informations concernant la mise à jour automatique de repomanager
if [ -z $(grep "^UPDATE_BACKUP=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ] ;then
	if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'UPDATE_BACKUP' n'est pas renseignée dans le fichier de conf repomanager.conf."
		(( CHECK_CONF_ERROR++ ))
	else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
		echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
		install
	fi
else # On récupère la valeur de UPDATE_BACKUP car on va en avoir besoin pour vérifier la condition suivante
	UPDATE_BACKUP=$(grep "^UPDATE_BACKUP=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')
fi

# Cas où le fichier de conf existe ; on récupère les informations concernant la mise à jour automatique de repomanager
if [ -z $(grep "^UPDATE_BACKUP_DIR=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ] ;then
	if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'UPDATE_BACKUP_DIR' n'est pas renseignée dans le fichier de conf repomanager.conf."
		(( CHECK_CONF_ERROR++ ))
	else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
		echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
		install
	fi
else # On récupère la valeur de UPDATE_BACKUP_DIR car on va en avoir besoin pour vérifier la condition suivante
	UPDATE_BACKUP_DIR=$(grep "^UPDATE_BACKUP_DIR=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')
fi

# Cas où le fichier de conf existe ; on récupère les informations concernant le module web
if [ -z $(grep "^WWW_ENABLED=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
	if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'WWW_ENABLED' n'est pas renseignée dans le fichier de conf repomanager.conf."
		(( CHECK_CONF_ERROR++ ))
	else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
		echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
		install
	fi
else # On récupère la valeur de WWW_ENABLED car on va en avoir besoin pour vérifier la condition suivante
	WWW_ENABLED=$(grep "^WWW_ENABLED=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')
fi

# Si le module web est activé, on va récupérer l'utilisateur web
if [ "$WWW_ENABLED" == "yes" ];then
	if [ -z $(grep "^WWW_USER=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
		if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
			MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'WWW_USER' n'est pas renseignée dans le fichier de conf repomanager.conf."
			(( CHECK_CONF_ERROR++ ))
		else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
			echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
			install
		fi
	fi

    if [ -z $(grep "^WWW_HOSTNAME=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
		if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
			MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'WWW_HOSTNAME' n'est pas renseignée dans le fichier de conf repomanager.conf."
			(( CHECK_CONF_ERROR++ ))
		else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
			echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
			install
		fi
	fi
fi

# Cas où le fichier de conf existe ; on récupère l'environnement (env) par défaut
if [ -z $(cat $ENV_CONF | grep -v '[ENVIRONNEMENTS]' | head -n1) ];then
	if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
        MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nIl ne semble pas y avoir d'environnement renseigné dans la section [ENVIRONNEMENTS] du fichier de conf repomanager.conf."
        (( CHECK_CONF_ERROR++ ))
	else
		echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
		install
	fi
fi


# Cas où le fichier de conf existe ; on récupère les informations concernant l'automatisation
if [ -z $(grep "^AUTOMATISATION_ENABLED=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
	if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'AUTOMATISATION_ENABLED' n'est pas renseignée dans le fichier de conf repomanager.conf."
		(( CHECK_CONF_ERROR++ ))
	else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
		echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
		install
	fi
else # On récupère la valeur de WWW_ENABLED car on va en avoir besoin pour vérifier la condition suivante
	AUTOMATISATION_ENABLED=$(grep "^AUTOMATISATION_ENABLED=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')
fi

# Cas où l'automatisation est activée, 
if [ "$AUTOMATISATION_ENABLED" == "yes" ];then

	# si on a activé l'automatisation mais que le fichier de planifications n'existe pas alors on le crée
	if [ ! -f "$PLAN_CONF" ];then
		echo "[PLANIFICATIONS]" > $PLAN_CONF
	fi

    if [ -z $(grep "^ALLOW_AUTOUPDATE_REPOS=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
        if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
            MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'ALLOW_AUTOUPDATE_REPOS' n'est pas renseignée dans le fichier de conf repomanager.conf."
            (( CHECK_CONF_ERROR++ ))
        else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
            echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
            install
        fi
    fi

    if [ -z $(grep "^ALLOW_AUTOUPDATE_REPOS_ENV=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
        if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
            MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'ALLOW_AUTOUPDATE_REPOS_ENV' n'est pas renseignée dans le fichier de conf repomanager.conf."
            (( CHECK_CONF_ERROR++ ))
        else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
            echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
            install
        fi
    fi

    if [ -z $(grep "^ALLOW_AUTODELETE_ARCHIVED_REPOS=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
        if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
            MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'ALLOW_AUTODELETE_ARCHIVED_REPOS' n'est pas renseignée dans le fichier de conf repomanager.conf."
            (( CHECK_CONF_ERROR++ ))
        else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
            echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
            install
        fi
	else # On récupère la valeur de ALLOW_AUTODELETE_ARCHIVED_REPOS car on va en avoir besoin pour vérifier la condition suivante
		ALLOW_AUTODELETE_ARCHIVED_REPOS=$(grep "^ALLOW_AUTODELETE_ARCHIVED_REPOS=" "$CONF" | cut -d'=' -f2 | sed 's/"//g')
    fi

    if [ "$ALLOW_AUTODELETE_ARCHIVED_REPOS" == "yes" ];then
        SUPPR_AUTO="1"

        if [ -z $(grep "^RETENTION=" "$CONF" | cut -d'=' -f2 | sed 's/"//g') ];then
            if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
                MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa variable 'RETENTION' n'est pas renseignée dans le fichier de conf repomanager.conf."
                (( CHECK_CONF_ERROR++ ))
            else # Si en mode pas-auto, on demande l'info directement à l'utilisateur
                echo -e "[$JAUNE WARNING $RESET] Fichier de conf repomanager.conf incomplet..."
                install
            fi
        fi
    fi
fi


### 3 ###
# Suppression des commentaires dans le fichier de conf
nettoyage_fichier_conf

## Si le script est lancé en mode auto, celui ci va se baser sur les sections [REPOS] et [PLANIFICATION] pour être autonome. On vérifie alors que ces sections existe dans le fichier de conf et qu'elles ne sont pas vides.
#if [ "$SYNC_AUTO" -eq "1" ] || [ "$PROD_AUTO" -eq "1" ];then
#	# On vérifie que la section [REPOS] existe
#	if ! grep -q "\[REPOS\]" "$CONF";then
#		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Aucune section [REPOS] trouvée dans le fichier de conf repomanager.conf..."
#        (( CHECK_CONF_ERROR++ ))
#    fi
#	# On vérifie que la section [REPOS] n'est pas vide et qu'elle contient des repos à traiter 
#	LISTE_DEPOTS=$(sed -n "/\[REPOS\]/,/\[/p" "$CONF" | egrep "^.*:")
#    if [ -z "$LISTE_DEPOTS" ];then
#        MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Aucun dépôt renseigné dans la section [REPOS] du fichier de conf repomanager.conf..."
#        (( CHECK_CONF_ERROR++ ))
#    fi
#
#	# On vérifie que la section [PLANIFICATION] existe
#	if ! grep -q "\[PLANIFICATION\]" "$CONF";then
#		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Aucune section [PLANIFICATIONS] trouvée dans le fichier de conf repomanager.conf..."
#        (( CHECK_CONF_ERROR++ ))
#    fi
#	# On vérifie que la section [PLANIFICATION] n'est pas vide et qu'elle contient des tâches à traiter
#	LISTE_PLANIFS=$(sed -n "/\[PLANIFICATION\]/,/\[/p" "$CONF" | egrep "^.*:")
#    if [ -z "$LISTE_PLANIFS" ];then
#        MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Aucune planification renseignée dans la section [PLANIFICATION] du fichier de conf repomanager.conf..."
#    	(( CHECK_CONF_ERROR++ ))
#    fi
#
#        #if [ "$SUPPR_AUTO" -eq "1" ];then
#        #        LISTE_ARCHIVES_A_SUPPR=$(sed -n "/\[NETTOYAGE_AUTO\]/,/\[/p" "$CONF" | egrep "^.*:.*:")
#        #        if [ -z "$LISTE_ARCHIVES_A_SUPPR" ];then
#        #                MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Aucun dépôt archivé renseigné dans la section [NETTOYAGE_AUTO] du fichier de conf repomanager.conf..."
#        #                (( CHECK_CONF_ERROR++ ))
#        #        fi
#fi


### 5 ### Fin des vérifications du fichier de conf, on vérifie la passphrase (on ne fait pas cette étape pour Debian)
if [ "$OS_FAMILY" == "Redhat" ];then
	if [ ! -f "$PASSPHRASE_FILE" ];then
		if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
			MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLe fichier passhrase est vide, les synchronisations automatiques de repos ne se lanceront pas..."
			(( CHECK_CONF_ERROR++ ))
		else # On crée le fichier si n'existe pas, puis on le configurera à l'étape suivante
			touch "$PASSPHRASE_FILE"
		fi
	fi

	# Si le fichier passphrase existe mais est vide
	if [ ! -s "$PASSPHRASE_FILE" ];then
		if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on ne fait rien à part envoyer un mail d'erreur
			MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLe fichier passhrase est vide, les synchronisations automatiques de repos ne se lanceront pas..."
			(( CHECK_CONF_ERROR++ ))
		else
			echo -ne "Le fichier passhrase est vide. Tapez [Entrée] pour configurer le fichier de passphrase : "; read -p "" CONFIRM &&
			/usr/bin/vim "$PASSPHRASE_FILE" &&
			if [ ! -s "$PASSPHRASE_FILE" ];then
				echo -e "\n${ROUGE} Le fichier passhrase est laissé vide, les synchronisations automatiques de repos ne se lanceront pas...${RESET}"
			fi &&
			(( CHECK_CONF_ERROR++ ))
			sleep 1
		fi
	fi

	# Si le fichier passphrase existe et n'est pas vide alors on teste la passphrase 
	if [ -f "$PASSPHRASE_FILE" ] && [ -s "$PASSPHRASE_FILE" ];then
		chmod 600 "$PASSPHRASE_FILE"
		GPG_VERSION=$(gpg --version | head -n1 | grep "gpg (GnuPG)" | awk -F ' ' '{print $3}')
		if [ -z "$GPG_VERSION" ];then
			echo -e "[${ROUGE} ERREUR ${RESET}] Impossible de déterminer la version de gpg"
			clean_exit
		fi
		if echo "$GPG_VERSION" | grep -q "2.2.";then # Si la version de gpg est au moins de 2.2. on peut utiliser l'option --pinentry-mode
			PASSPHRASE_TEST=$(echo "test" | gpg2 --homedir ${GPGHOME} -q --sign --passphrase-file ${PASSPHRASE_FILE} --batch --local-user ${GPG_KEYID} --no-permission-warning --output /dev/null --yes --pinentry-mode loopback && echo "Passphrase OK")
		else
			PASSPHRASE_TEST=$(echo "test" | gpg2 --homedir ${GPGHOME} -q --sign --passphrase-file ${PASSPHRASE_FILE} --batch --local-user ${GPG_KEYID} --no-permission-warning --output /dev/null --yes && echo "Passphrase OK")
		fi
		if [ "$TTY" -eq "0" ];then # Si le script est lancé en auto (pas de terminal, via crontab), alors on effectue le test et on envoie un mail en cas d'échec
			if [[ "$PASSPHRASE_TEST" != *"Passphrase OK"* ]];then
				MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\nLa passphrase configurée dans le fichier ${PASSPHRASE_FILE} n'est pas bonne." &&
				(( CHECK_CONF_ERROR++ ))
			fi
		else
			while [[ "$PASSPHRASE_TEST" != *"Passphrase OK"* ]];do
				echo -e "Mauvaise passphrase" &&
				echo -e " Tapez [Entrée] pour configurer le fichier de passphrase : "; read -p "" CONFIRM &&
				/usr/bin/vim "$PASSPHRASE_FILE"
				if echo "$GPG_VERSION" | grep -q "2.2.";then # Si la version de gpg est au moins de 2.2. on peut utiliser l'option --pinentry-mode
					PASSPHRASE_TEST=$(echo "test" | gpg2 --homedir ${GPGHOME} -q --sign --passphrase-file ${PASSPHRASE_FILE} --batch --local-user ${GPG_KEYID} --no-permission-warning --output /dev/null --yes --pinentry-mode loopback && echo "Passphrase OK")
				else
					PASSPHRASE_TEST=$(echo "test" | gpg2 --homedir ${GPGHOME} -q --sign --passphrase-file ${PASSPHRASE_FILE} --batch --local-user ${GPG_KEYID} --no-permission-warning --output /dev/null --yes && echo "Passphrase OK")
				fi
				(( CHECK_CONF_ERROR++ ))
			done
		fi
	else
		echo "Erreur le fichier passphrase est vide ou n'existe pas"
		clean_exit
	fi
fi

### 6 ### Vérification de la présence du module perl RPM4 permettant de signer les paquets
if [ "$OS_FAMILY" == "Redhat" ];then
	if [ ! -f "/usr/bin/rpmresign" ];then	# Dans tous les cas (auto ou manuel) on va afficher l'erreur suivante 
		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Le module RPM4 contenant rpmresign ne semble pas installé..."
		(( CHECK_CONF_ERROR++ ))
	fi
fi


### 7 ### Vérifie que les infos présentes dans repos.list sont cohérentes par rapport au contenu de ${REPOS_DIR}/
# La vérification se fait uniquement si le fichier n'est pas vide (cas où c'est la première install de repomanager et qu'aucun repo n'a encore été créé)
# La vérification se fait en deux fois
# Première vérif : lit chaque ligne du fichier repos.list et vérifie qu'un snapshot (répertoire) correspondant est bien présent dans ${REPOS_DIR}/
# Deuxième vérif : dans l'autre sens : lit les snapshots dans ${REPOS_DIR}/ et vérifie qu'une ligne corespondante est bien présente dans repos.list
# Fait la même chose pour repos-archive.list

## Cas Redhat ##

if [ "$OS_FAMILY" == "Redhat" ];then

	if [ -s "$REPOS_LIST" ];then # Si le fichier n'est pas vide alors on peut vérifier que son contenu est cohérent avec ${REPOS_DIR}/
		sortLists # On tri le contenu des fichiers de liste

		# Première vérif :
		# Parcours du fichier repos.list (Pour l'exemple, disons qu'il existe une ligne 'base:default:prod:01-09-2017:description' dans le fichier repos.list)
		while IFS=, read REPO_NAME REPO_REALNAME REPO_ENV REPO_DATE REPO_DESCRIPTION;do
			REPO_NAME=$(echo "$REPO_NAME" | cut -d'=' -f2 | sed 's/"//g')
			REPO_ENV=$(echo "$REPO_ENV" | cut -d'=' -f2 | sed 's/"//g')
			REPO_DATE=$(echo "$REPO_DATE" | cut -d'=' -f2 | sed 's/"//g')
			# Pour 'base:default:prod:01-09-2017', on vérifie qu'un lien symbolique 'base_prod' existe dans ${REPOS_DIR}/
			if [ -L "${REPOS_DIR}/${REPO_NAME}_${REPO_ENV}" ];then
				# Ok le lien symbolique existe, il pointe donc vers un snapshot, mais reste à savoir si il s'agit de la bonne date
				# Pour que ça soit bon il faut donc qu'il pointe vers le répertoire '01-09-2017_base/' :
				if [ "$(readlink "${REPOS_DIR}/${REPO_NAME}_${REPO_ENV}")" = "${REPO_DATE}_${REPO_NAME}/" ];then 
					continue	# Si c'est OK, on continue (on passe à la ligne suivante dans le fichier repos.list)
				else	# Sinon si le lien symb' ne pointe sur rien ou sur une date différente de celle du fichier, alors il y a une erreur de concordance, on exit le script
					MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Il y a une incohérence avec le dépôt '${REPO_NAME}:${REPO_ENV}:${REPO_DATE}' et le contenu du répertoire '${REPOS_DIR}/'. Il faut corriger manuellement !"
					(( CHECK_CONF_ERROR++ )) 
				fi
			else	# Cas où il n'y a aucun lien symbolique dans '${REPOS_DIR}/sys/' qui correspond à la ligne 'base:prod:01-09-2017'
				MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Il n'existe pas de repo dans '${REPOS_DIR}/' pour '${REPO_NAME}:${REPO_ENV}:${REPO_DATE}'. Il faut corriger manuellement !"
				(( CHECK_CONF_ERROR++ )) 
			fi
		done < $REPOS_LIST
	fi

	# On fait la même chose pour repos-archive.list
	# Première vérif :
	# Parcourt du fichier repos-archive.list
	if [ -s "$REPOS_ARCHIVE_LIST" ];then
		sortLists # On tri le contenu des fichiers de liste
		while IFS=, read REPO_NAME REPO_REALNAME REPO_DATE REPO_DESCRIPTION;do
			REPO_NAME=$(echo "$REPO_NAME" | cut -d'=' -f2 | sed 's/"//g')
			REPO_DATE=$(echo "$REPO_DATE" | cut -d'=' -f2 | sed 's/"//g')
			if [ ! -d "${REPOS_DIR}/99_old_version_${REPO_DATE}_${REPO_NAME}" ];then
				MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Il n'existe aucune version archivée '$REPO_NAME:$REPO_DATE' dans le répertoire '${REPOS_DIR}/'. Il faut corriger manuellement !"
				(( CHECK_CONF_ERROR++ ))
				clean_exit
			fi

		done < $REPOS_ARCHIVE_LIST
	fi

	# Deuxième vérif (dans l'autre sens) :
	if [ ! -z "$(ls -A ${REPOS_DIR}/)" ];then
		# repos.list :
		cd ${REPOS_DIR}/ &&
		for LIEN in $(ls -A1);do	# On liste le contenu du répertoire ${REPOS_DIR}/
			if [ -L "$LIEN" ];then 	# Si il s'agit d'un lien symbolique alors on récupère le nom du snapshot vers lequel il pointe
				REPO_ENV=$(echo $LIEN | cut -d'_' -f 2)	# Récup de l'env (prod, test)
				SNAPSHOT=$(readlink "$LIEN")				# Récup du snapshot vers lequel il pointe (ex 01-09-2017_base/)
				REPO_DATE=$(echo $SNAPSHOT | cut -d'_' -f 1)		# De ce snapshot on extrait sa date (01-09-2017)
				REPO_NAME=$(echo $SNAPSHOT | cut -d'_' -f 2)		# et le nom du repo (base/)
				REPO_NAME=${REPO_NAME%/}							# on enlève le slash à la fin du nom (base) c'est mieux
				if [ ! -d "$SNAPSHOT" ];then
					MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Le lien symbolique '$LIEN' pointe vers le snapshot '$SNAPSHOT' qui n'existe pas/plus. Ce lien est donc mort il faut corriger manuellement !"		
					(( CHECK_CONF_ERROR++ ))
				fi
				if egrep -q "^Name=\"${REPO_NAME}\",Realname=\".*\",Env=\"${REPO_ENV}\",Date=\"${REPO_DATE}\"" "$REPOS_LIST";then	# Si on retrouve les infos extraites dans le fichier repos.list,
					continue						# alors c'est OK et on passe au suivant
				else
					MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Le fichier repos.list ne contient aucune info pour '$LIEN -> $SNAPSHOT'. Il faut corriger manuellement !" # Sinon il y a une incohérence 
					(( CHECK_CONF_ERROR++ ))
				fi
			fi
		done
	
		# Deuxième vérif (dans l'autre sens) (pour sys et spec) :
		cd ${REPOS_DIR}/ &&
		for REP in $(ls -A1);do
			if [[ "$REP" =~ ^99_old_version.* ]];then
				REPO_DATE=$(echo $REP | cut -d'_' -f4)
				REPO_NAME=$(echo $REP | cut -d'_' -f5)
				REPO_NAME=${REPO_NAME%/}
				if egrep -q "^Name=\"${REPO_NAME}\",Realname=\".*\",Date=\"${REPO_DATE}\"" "$REPOS_ARCHIVE_LIST";then
					continue
				else
					MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Le fichier repos-archive.list ne contient aucune info pour '99_old_version_${REPO_DATE}_${REPO_NAME}'. Il faut corriger manuellement !"
					(( CHECK_CONF_ERROR++ ))
				fi
			fi
		done
	fi
fi


## Cas Debian ##
# La vérification se fait uniquement si le fichier n'est pas vide (cas où c'est la première install de repomanager et qu'aucun repo n'a encore été créé)
# La vérification se fait en deux fois
# Première vérif : lit chaque ligne du fichier repos.list et vérifie qu'un snapshot (répertoire) correspondant est bien présent dans ${REPOS_DIR}/
# Deuxième vérif : dans l'autre sens : lit les snapshots dans ${REPOS_DIR}/ et vérifie qu'une ligne corespondante est bien présente dans repos.list
# Fait la même chose pour repos-archive.list
if [ "$OS_FAMILY" == "Debian" ];then

	if [ -s "$REPOS_LIST" ];then
		sortLists # On tri le contenu des fichiers de liste

		# Première vérif :
		# Parcours du fichier repos.list (Pour l'exemple, disons qu'il existe une ligne 'ftp.fr.debian.org:wheezy:main:prod:01-09-2017:description' dans le fichier repos.list)
		while IFS=, read REPO_NAME REPO_HOST REPO_DIST REPO_SECTION REPO_ENV REPO_DATE REPO_DESCRIPTION;do
			REPO_NAME=$(echo "$REPO_NAME" | cut -d'=' -f2 | sed 's/"//g')
			REPO_DIST=$(echo "$REPO_DIST" | cut -d'=' -f2 | sed 's/"//g')
			REPO_SECTION=$(echo "$REPO_SECTION" | cut -d'=' -f2 | sed 's/"//g')
			REPO_ENV=$(echo "$REPO_ENV" | cut -d'=' -f2 | sed 's/"//g')
			REPO_DATE=$(echo "$REPO_DATE" | cut -d'=' -f2 | sed 's/"//g')

			if [ ! -d "${REPOS_DIR}/${REPO_NAME}" ];then # On vérifie d'abord si le repo ftp.fr.debian.org existe
				echo -e "[${ROUGE} ERREUR ${RESET}]\n Il n'existe pas de repo dans '${REPOS_DIR}/' pour '${REPO_NAME}:${REPO_DIST}:${REPO_SECTION}:${REPO_ENV}:${REPO_DATE}'. Il faut corriger manuellement !\n"
				clean_exit
			fi

			if [ ! -d "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}" ];then   # On vérifie ensuite si la distribution/version (wheezy, stretch...) existe
				echo -e "[${ROUGE} ERREUR ${RESET}]\n Il n'existe pas de distribution ${CYAN}${REPO_DIST}${RESET} dans '${REPOS_DIR}/${REPO_NAME}/' pour '${REPO_NAME}:${REPO_DIST}:${REPO_SECTION}:${REPO_ENV}:${REPO_DATE}'. Il faut corriger manuellement !\n"
				clean_exit
			fi
		
			# Enfin on vérifie si la section existe :
			# Donc pour 'ftp.fr.debian.org:wheezy:main:prod:01-09-2017', on vérifie qu'un lien symbolique 'main_prod' existe dans ${REPOS_DIR}/ftp.fr.debian.org/wheezy/
			if [ -L "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${REPO_SECTION}_${REPO_ENV}" ];then
				# Ok le lien symbolique existe, il pointe donc vers un snapshot, mais reste à savoir si il s'agit de la bonne date
				# Pour que ça soit bon il faut donc qu'il pointe vers le répertoire '01-09-2017_main/' :
				if [ "$(readlink "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${REPO_SECTION}_${REPO_ENV}")" = "${REPO_DATE}_${REPO_SECTION}/" ];then 
					continue  # Si c'est OK, on continue (on passe à la ligne suivante dans le fichier repos.list)
				else  # Sinon si le lien symb' ne pointe sur rien ou sur une date différente de celle du fichier, alors il y a une erreur de concordance, on clean_exit le script
					echo -e "[${ROUGE} ERREUR ${RESET}]\n Il y a une incohérence avec le dépôt '${REPO_NAME}:${REPO_DIST}:${REPO_SECTION}:${REPO_ENV}:${REPO_DATE}' et le contenu du répertoire '${REPOS_DIR}/'. Il faut corriger manuellement !\n"
					clean_exit 
				fi
			else  # Cas où il n'y a aucun lien symbolique dans '${REPOS_DIR}/*/*/' qui correspond à la ligne 'ftp.fr.debian.org:wheezy:main:prod'
				echo -e "[${ROUGE} ERREUR ${RESET}]\n Il n'existe pas de section dans '${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/' pour '${REPO_NAME}:${REPO_DIST}:${REPO_SECTION}:${REPO_ENV}:${REPO_DATE}'. Il faut corriger manuellement !\n"
				clean_exit 
			fi
		done < $REPOS_LIST
	fi

	# On fait la même chose pour repos-archive.list
	# Parcourt du fichier repos-archive.list
	if [ -s "$REPOS_ARCHIVE_LIST" ];then
		sortLists # On tri le contenu des fichiers de liste
		while IFS=, read REPO_NAME REPO_HOST REPO_DIST REPO_SECTION REPO_DATE REPO_DESCRIPTION;do
			REPO_NAME=$(echo "$REPO_NAME" | cut -d'=' -f2 | sed 's/"//g')
			REPO_DIST=$(echo "$REPO_DIST" | cut -d'=' -f2 | sed 's/"//g')
			REPO_SECTION=$(echo "$REPO_SECTION" | cut -d'=' -f2 | sed 's/"//g')
			REPO_DATE=$(echo "$REPO_DATE" | cut -d'=' -f2 | sed 's/"//g')
			if [ ! -d "${REPOS_DIR}/${REPO_NAME}" ];then   # On vérifie d'abord si le repo existe
				echo -e "[${ROUGE} ERREUR ${RESET}]\n Il n'existe pas de repo dans '${REPOS_DIR}/' pour '${REPO_NAME}:${REPO_DIST}:${REPO_SECTION}:${REPO_DATE}'. Il faut corriger manuellement !\n"
				clean_exit
			fi

			if [ ! -d "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}" ];then   # On vérifie ensuite si la distribution/version (wheezy, stretch...) existe
				echo -e "[${ROUGE} ERREUR ${RESET}]\n Il n'existe pas de distribution ${CYAN}${REPO_DIST}${RESET} dans '${REPOS_DIR}/${REPO_NAME}/' pour '${REPO_NAME}:${REPO_DIST}:${REPO_SECTION}:${REPO_DATE}'. Il faut corriger manuellement !\n"
				clean_exit
			fi

			# Enfin on vérifie si la section existe :
			if [ ! -d "${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/99_old_version_${REPO_DATE}_${REPO_SECTION}" ];then
				echo -e "[${ROUGE} ERREUR ${RESET}]\n Il n'existe aucune version archivée '${REPO_NAME}:${REPO_DIST}:${REPO_SECTION}:${REPO_DATE}' dans le répertoire '${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/'. Il faut corriger manuellement !\n"
				clean_exit
			fi
		done < $REPOS_ARCHIVE_LIST
	fi

	# Deuxième vérif (dans l'autre sens) :
	if [ ! -z "$(ls -A ${REPOS_DIR}/)" ];then
		# repos.list :
		cd ${REPOS_DIR}/ &&
		for REPO_NAME in */;do
			if [ "$REPO_NAME" == "profils/" ];then continue;fi # Si le répertoire traité est le répoertoire des profils "profils/" alors on ignore et on passe au suivant
			REPO_NAME=${REPO_NAME%/}  # On enlève le slash à la fin du nom (ftp.fr.debian.org) c'est mieux
			cd $REPO_NAME/ &&
			for REPO_DIST in */;do
				REPO_DIST=${REPO_DIST%/}  # On enlève le slash à la fin du nom (wheezy) c'est mieux
				cd $REPO_DIST/ &&
				for LIEN in $(ls -A1);do # On liste le contenu du répertoire ${REPOS_DIR}/*/
					if [ -L "$LIEN" ];then  # Si il s'agit d'un lien symbolique alors on récupère le nom du snapshot vers lequel il pointe
						REPO_ENV=$(echo $LIEN | cut -d'_' -f 2) # Récup de l'env (prod, test)
						SNAPSHOT=$(readlink "$LIEN")    # Récup du snapshot vers lequel il pointe (ex 01-09-2017_main/)
						REPO_DATE=$(echo $SNAPSHOT | cut -d'_' -f 1) # De ce snapshot on extrait sa date (01-09-2017)
						REPO_SECTION=$(echo $SNAPSHOT | cut -d'_' -f 2)  # et le nom du repo (main/)
						REPO_SECTION=${REPO_SECTION%/}        # on enlève le slash à la fin du nom (main) c'est mieux
						if [ ! -d "$SNAPSHOT" ];then  # Première vérif : on vérifie que le snapshot existe vraiment (car il pourrait très bien s'agir d'un lien symbolique cassé)
							echo -e "[${ROUGE} ERREUR ${RESET}]\n Le lien symbolique '${LIEN}' (repo ${CYAN}${REPO_NAME}${RESET}, distribution ${CYAN}${REPO_DIST}${RESET}, section ${CYAN}${REPO_SECTION}${RESET}) pointe vers le snapshot '${SNAPSHOT}' qui n'existe pas/plus. Ce lien est donc mort il faut corriger manuellement !"
							clean_exit
						fi
			
						if echo "$REPO_DIST" | egrep -q ".*_.*"; then  # Si le nom de la distrib comporte un _ alors cela correspond à un slash dans le fichier repos.list,
							DIST=$(echo $REPO_DIST | sed -e 's/_/\//g')  # (ex: wheezy_updates dans ${REPOS_DIR}/X/ correpond à wheezy/updates dans repos.list
						fi
						if egrep -q "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_ENV}\",Date=\"${REPO_DATE}\"" "$REPOS_LIST";then # Si on retrouve les infos extraites dans le fichier repos.list,
							continue   # alors c'est OK et on passe au suivant
						else
							DIST=$(echo $REPO_DIST | sed -e 's/_/\//g')  # La vérif précédente a échouée mais c'est peut-être parce que la distrib possède un slash (ex wheezy/updates) dans le fichier repos.list, du coup on formates (remplace tiret par un slash) et on refait la vérif
							if egrep -q "^Name=\"${REPO_NAME}/.*\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Env=\"${REPO_ENV}\",Date=\"${REPO_DATE}\"" "$REPOS_LIST";then
								continue
							else
								echo -e "[${ROUGE} ERREUR ${RESET}]\n Le fichier repos.list ne contient aucune info pour '${REPOS_DIR}/${REPO_NAME}/${REPO_DIST}/${LIEN} -> $SNAPSHOT'. Il faut corriger manuellement !" # Sinon il y a une incohérence 
								clean_exit
							fi
						fi      
					fi
				done
				cd ${REPOS_DIR}/${REPO_NAME}/ # Retour au répertoire du repo pour traiter une éventuelle distrib/version suivante 
			done
			cd ${REPOS_DIR}/ # Retour au répertoire de base pour traiter le repo suivant
		done

		# On fait la même chose pour repos-archive.list :
		cd ${REPOS_DIR}/ &&
		for REPO_NAME in */;do
			REPO_NAME=${REPO_NAME%/}  # On enlève le slash à la fin du nom (ftp.fr.debian.org) c'est mieux
			cd $REPO_NAME/ &&
			for REPO_DIST in */;do
				REPO_DIST=${REPO_DIST%/}  # On enlève le slash à la fin du nom (wheezy) c'est mieux
				cd $REPO_DIST/ &&
				for LIEN in $(ls -A1);do  # On liste le contenu du répertoire ${REPOS_DIR}/*/ et pour chaque lien trouvé,
					if [[ "$LIEN" =~ ^99_old_version.* ]];then  # si celui-ci commence par 99_old_version, alors on traite (ex : 99_old_version_02-03-2018_contrib) 
						REPO_DATE=$(echo $LIEN | cut -d'_' -f4)    # On extrait sa date (02-03-2018)
						REPO_SECTION=$(echo $LIEN | cut -d'_' -f5)   # On extrait sa section (contrib)
						if ! egrep -q "^Name=\"${REPO_NAME}\",Host=\".*\",Dist=\"${REPO_DIST}\",Section=\"${REPO_SECTION}\",Date=\"${REPO_DATE}\"" "$REPOS_ARCHIVE_LIST";then
							echo -e "[${ROUGE} ERREUR ${RESET}]\n Le fichier repos-archive.list ne contient aucune info pour '99_old_version_${REPO_DATE}_${REPO_NAME}'. Il faut corriger manuellement !"
							clean_exit
						fi
					fi
				done
				cd ${REPOS_DIR}/${REPO_NAME}/ # Retour au répertoire du repo pour traiter une éventuelle distrib/version suivante
			done
			cd ${REPOS_DIR}/ # Retour au répertoire de base pour traiter le repo suivant
		done
	fi
fi

### 8 ### Vérification que l'espace disque est suffisant 
ESPACE_DISQUE=$(df | egrep "/$" | awk '{print $4}')   # Affichage de l'espace restant sur /home
if [ $ESPACE_DISQUE -lt 15000000 ];then
    MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Espace disque insuffisant pour traiter correctement les repos..."
    (( CHECK_CONF_ERROR++ ))
fi


### 9 ###
#LISTE_DE_PLANIFICATIONS=$(sed -n "/\[PLANIFICATION\]/,/\[/p" "$PLAN_CONF" | egrep "^.*:")	# Récupération de la liste de toutes les planifications dans le fichier de conf
#
## 2019-07-03:09h00:@groupe:action:10days,7days
#for PLANIFICATION in $(echo ${LISTE_DE_PLANIFICATIONS}); do
#	DATE=$(echo "$PLANIFICATION" | awk -F: '{print $1}')	# Parsage de la planification pour récupérer les infos data heure etc
#	HEURE=$(echo "$PLANIFICATION" | awk -F: '{print $2}')
#	GROUPE=$(echo "$PLANIFICATION" | awk -F: '{print $3}')
#	ACTION=$(echo "$PLANIFICATION" | awk -F: '{print $4}')
#	RAPPELS=$(echo "$PLANIFICATION" | awk -F: '{print $5}')
#
#	if [ -z "$DATE" ] || [ -z "$HEURE" ] || [ -z "$ACTION" ] || [ -z "$RAPPELS" ];then
#		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Le paramétrage de la planification $PLANIFICATION est incomplet. Il doit manquer un paramètre comme la date, l'heure ou autre chose..."
#		(( CHECK_CONF_ERROR++ ))
#		continue
#	fi
#	
#	if ! echo "$DATE" | egrep -q "[0-9][0-9][0-9][0-9]\-[0-1][0-9]\-[0-3][0-9]";then
#		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] La syntaxe de la date n'est pas bonne (syntaxe : 2019-12-31) pour la planification : $PLANIFICATION"
#        (( CHECK_CONF_ERROR++ ))
#        continue
#	fi
#
#	if ! echo "$HEURE" | grep -q "[0-9][0-9]h[0-9][0-9]";then
#		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] La syntaxe de l'heure n'est pas bonne (syntaxe : 00h00) pour la planification : $PLANIFICATION"
#        (( CHECK_CONF_ERROR++ ))
#        continue
#	fi
#	
#	if [ ! -z "$GROUPE" ];then # Si un groupe a été défini, alors ce sont les repos de ce groupe qui seront traités
#		# On vérifie que le groupe est bien présent dans le fichier de conf et qu'il comporte des repos à traiter
#		if ! egrep -q "^$GROUPE" "$CONF";then
#			MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Le groupe $GROUPE n'existe pas dans repomanager.conf pour la planification : $PLANIFICATION"
#			(( CHECK_CONF_ERROR++ ))
#	    	continue
#		fi
#		# Si le groupe existe alors on récupère la liste des repos membres de ce groupe
#		LISTE_DEPOTS=$(sed -n "/\[REPOS\]/,/\[/p" "$CONF" | sed -n "/$GROUPE/,/^@/p" | egrep "^.*:")
#		# Si la liste est vide alors on indique une erreur et on passe à la planification suivante (continue)
#		if [ -z "$LISTE_DEPOTS" ];then
#			MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] Le groupe $GROUPE ne comporte aucun repos dans repomanager.conf. Il n'y a donc rien à traiter pour la planification : $PLANIFICATION"
#            (( CHECK_CONF_ERROR++ ))
#            continue
#		fi
#	fi
#
#	# On vérifie que l'action indiquée dans la planification est valable (3 actions sont possibles : synchro, prod ou suppression-archivage), sinon on indique une erreur et on passe au suivant:
#	if [ "$ACTION" != "synchro" ] && [ "$ACTION" != "prod" ] && [ "$ACTION" != "suppression-archivage" ];then
#		MSG_CHECK_CONF_ERROR="${MSG_CHECK_CONF_ERROR}\n[${ROUGE} ERREUR ${RESET}] La syntaxe de l'action n'est pas bonne (ex d'action valide : 'synchro') pour la planification : $PLANIFICATION"
#        (( CHECK_CONF_ERROR++ ))
#        continue
#	fi
#done

# Si aucune erreur, alors on affiche OK pour la vérification des planifications, sinon on envoie par mail les erreurs rencontrées   
if [ "$CHECK_CONF_ERROR" -eq "0" ];then
    echo -e "[${VERT} OK ${RESET}]\n"
else
	echo -e "$MSG_CHECK_CONF_ERROR\n"  # Sinon on affiche toutes les erreurs recontrées et concaténées dans la variable $MSG_CHECK_CONF_ERROR afin qu'elles apparraissent dans le log
    clean_exit
fi