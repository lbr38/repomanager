#!/bin/bash
# On traite les planifications et leur rappels dans ce même fichier car on utilise des fonctions de pré-vérification communes (on évite le code en doublon donc)

# Codes d'erreurs
# CP = Check Planification
# CP01
# CP02
# CP03

# PE = Planification Execution
# PE01
# PE02

# PR = Planification Reminder
# PR01
# PR02

# Fonctions de pré-vérifications
# Vérification de l'action
checkAction() {
	if [ -z "$PLAN_ACTION" ];then
		(( PLAN_ERROR++ ))
		MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP01) : Aucune action n'est spécifiée dans cette planification"
		plan_exit
	fi

	# Si l'action est 'update' alors on doit avoir renseigné PLAN_GPG_CHECK (+ PLAN_GPG_RESIGN pour redhat)
	if [ "$PLAN_ACTION" == "update" ];then
		# Si la mise à jour des repos n'est pas autorisée, on quitte
		if [ "$ALLOW_AUTOUPDATE_REPOS" != "yes" ];then
			(( PLAN_ERROR++ ))
			MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP02) : La mise à jour des miroirs par planification n'est pas autorisée. Vous pouvez modifier ce paramètre depuis l'onglet Paramètres."
			plan_exit
		fi

		if [ -z "$PLAN_GPG_CHECK" ];then
			(( PLAN_ERROR++ ))
			MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP03) : Vérification des signatures GPG non spécifié dans cette planification"
			plan_exit
		fi

		if [ "$OS_FAMILY" == "Redhat" ];then
			if [ -z "$PLAN_GPG_RESIGN" ];then
				(( PLAN_ERROR++ ))
				MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP04) : Signature des paquets avec GPG non spécifié dans cette planification"
				plan_exit
			fi
		fi
	fi

	if [[ "$PLAN_ACTION" =~ "->" ]];then
		# Si le changement d'environnement n'est pas autorisé, on quitte
		if [ "$ALLOW_AUTOUPDATE_REPOS_ENV" != "yes" ];then
			(( PLAN_ERROR++ ))
			MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP05) : Le changement d'environnement par planification n'est pas autorisé. Vous pouvez modifier ce paramètre depuis l'onglet Paramètres."
			plan_exit
		fi
	fi
}

# Vérification si on traite un repo seul ou un groupe
checkIfRepoOrGroup() {
	if [ -z "$PLAN_REPO_NAME" ] && [ -z "$PLAN_GROUP" ];then
		(( PLAN_ERROR++ ))
		MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP06) : Aucun repo ou groupe spécifié"
		plan_exit
	fi

	# On va traiter soit un repo soit un groupe de repo, ça ne peut pas être les deux, donc on vérifie que PLAN_REPO et PLAN_GROUP ne sont pas tous les deux renseignés en même temps :
	if ([ ! -z "$PLAN_REPO_NAME" ] && [ ! -z "$PLAN_GROUP" ]);then
		(( PLAN_ERROR++ ))
		if [ "$OS_FAMILY" == "Redhat" ];then MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP07) : Il n'est pas possible de traiter à la fois un repo et un groupe de repos";fi
		if [ "$OS_FAMILY" == "Debian" ];then MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP07) : Il n'est pas possible de traiter à la fois une section et un groupe de sections";fi
		plan_exit
	fi

	# Si on a renseigné un seul repo à traiter alors il faut vérifier qu'il existe dans la liste (il a pu être supprimé depuis que la planification a été créée)
	# Puis il faut récupérer son vrai nom (Redhat) ou son hôte source (Debian)
	if [ ! -z "$PLAN_REPO_NAME" ];then
		if [ "$OS_FAMILY" == "Redhat" ];then
			# Vérification que le repo existe
			if ! grep -q "^Name=\"${PLAN_REPO_NAME}\"" $REPOS_LIST;then
				(( PLAN_ERROR++ ))
				MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP08) : Le repo ${PLAN_REPO_NAME} n'existe pas"
				plan_exit
			fi

			# Récupération du repo source
			PLAN_REPO_REALNAME=$(grep "^Name=\"${PLAN_REPO_NAME}\"" $REPOS_LIST | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
			if [ -z "$PLAN_REPO_REALNAME" ];then
				(( PLAN_ERROR++ ))
				MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP09) : Impossible de récupérer le nom du repo source"
				plan_exit
			fi
		fi

		if [ "$OS_FAMILY" == "Debian" ];then
			# On vérifie qu'on a bien renseigné la distribution et la section
			if [ -z "$PLAN_REPO_DIST" ];then
				(( PLAN_ERROR++ ))
				MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP10) : Aucune distribution spécifiée"
				plan_exit
			fi
			if [ -z "$PLAN_REPO_SECTION" ];then
				(( PLAN_ERROR++ ))
				MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP11) : Aucune section spécifiée"
				plan_exit
			fi

			# Vérification que la section existe
			if ! grep -q "^Name=\"${PLAN_REPO_NAME}\",Host=\".*\",Dist=\"${PLAN_REPO_DIST}\",Section=\"${PLAN_REPO_SECTION}\"" $REPOS_LIST;then
				(( PLAN_ERROR++ ))
				MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP12) : La section ${PLAN_REPO_SECTION} du repo ${PLAN_REPO_NAME} (distribution ${PLAN_REPO_DIST}) n'existe pas"
				plan_exit
			fi

			# Récupération de l'hote source
			PLAN_REPO_HOSTNAME=$(grep "^Name=\"${PLAN_REPO_NAME}\"" $REPOS_LIST | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
			if [ -z "$PLAN_REPO_HOSTNAME" ];then
				(( PLAN_ERROR++ ))
				MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP13) : Impossible de récupérer le nom de l'hôte source"
				plan_exit
			fi
		fi
	fi


	# Si on a renseigné un groupe (commence par @) plutôt qu'un seul repo à traiter, alors on vérifie que le groupe existe dans le fichier de groupe (il a pu être supprimé depuis que la planification a été créée)
	# Puis on récupère toute la liste du groupe
	if [ ! -z "$PLAN_GROUP" ];then
		# Vérification que le groupe existe
		if ! grep -q "\[${PLAN_GROUP}\]" $GROUPS_CONF;then
			(( PLAN_ERROR++ ))
			MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP14) : Le groupe ${PLAN_GROUP} n'existe pas"
			plan_exit
		fi

		# on récupère tous les repos du groupe
		PLAN_GROUP_LIST=$(cat "$GROUPS_CONF" | sed -n "/${PLAN_GROUP}/,/^@/p" | egrep "^Name=\".*\"")

		if [ -z "$PLAN_GROUP_LIST" ];then
			(( PLAN_ERROR++ ))
			if [ "$OS_FAMILY" == "Redhat" ];then MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP13) : Il n'y a aucun repo renseigné dans le groupe ${PLAN_GROUP}.";fi
			if [ "$OS_FAMILY" == "Debian" ];then MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP13) : Il n'y a aucune section renseignée dans le groupe ${PLAN_GROUP}.";fi
			plan_exit
		fi

		# Pour chaque repo/section renseigné(e), on vérifie qu'il/elle existe
		for LINE in $(echo "$PLAN_GROUP_LIST");do
			# Pour chaque ligne on récupère les infos du repo/section
				GROUP_REPO_NAME=$(echo $LINE | awk -F ',' '{print $1}' | cut -d'=' -f2 | sed 's/"//g')
			if [ "$OS_FAMILY" == "Redhat" ];then
				if ! grep -q "^Name=\"${GROUP_REPO_NAME}\"" $REPOS_LIST;then
					(( PLAN_ERROR++ ))
					MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP15) : Le repo ${GROUP_REPO_NAME} dans le groupe ${PLAN_GROUP} n'existe pas/plus."
					plan_exit
				fi
			fi

			if [ "$OS_FAMILY" == "Debian" ];then
				GROUP_REPO_DIST=$(echo $LINE | awk -F ',' '{print $3}' | cut -d'=' -f2 | sed 's/"//g')
				GROUP_REPO_SECTION=$(echo $LINE | awk -F ',' '{print $4}' | cut -d'=' -f2 | sed 's/"//g')
				if ! grep -q "^Name=\"${GROUP_REPO_NAME}\",Host=\".*\",Dist=\"${GROUP_REPO_DIST}\",Section=\"${GROUP_REPO_SECTION}\"" $REPOS_LIST;then
					(( PLAN_ERROR++ ))
					MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (CP16) : La section ${GROUP_REPO_SECTION} du repo ${GROUP_REPO_NAME} (distribution ${GROUP_REPO_DIST}) dans le groupe ${PLAN_GROUP} n'existe pas/plus."
					plan_exit
				fi				
			fi
		done
	fi
}


## TRAITEMENTS ##

# Traitement de la planification (numéro de planification spécifié en argument $1)
execute() {
echo -e "Traitement de la planification Plan-${PLAN_ID}\n"

# Si les planifications ne sont pas activées, on quitte
if [ "$AUTOMATISATION_ENABLED" != "yes" ];then
	(( PLAN_ERROR++ ))
	MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (EP01) : Les planifications ne sont pas activées. Vous pouvez modifier ce paramètre depuis l'onglet Paramètres."
	plan_exit
fi

# On vérifie qu'une planification possèdant l'ID ${PLAN_ID} existe vraiement dans planifications.conf
if ! grep "\[Plan-${PLAN_ID}\]" "$PLAN_CONF";then
	(( PLAN_ERROR++ ))
	MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (EP01) : Il n'existe aucune planification portant l'ID '${PLAN_ID}'"
	plan_exit
fi

# Récupération des détails de la planification actuelle dans le fichier de conf, afin de savoir quels repos sont impliqués et quelle action effectuer
PLAN_ACTION=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF" | grep "^Action=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_REPO_NAME=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF" | grep "^Repo=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_REPO_DIST=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF" | grep "^Dist=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_REPO_SECTION=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF" | grep "^Section=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_GROUP=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF" | grep "^Group=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_GPG_CHECK=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF" | grep "^GpgCheck=" | cut -d'=' -f2 | sed 's/"//g')
PLAN_GPG_RESIGN=$(sed -n "/\[Plan-${1}\]/,/\[/p" "$PLAN_CONF" | grep "^GpgResign=" | cut -d'=' -f2 | sed 's/"//g')

# Initialisation de variables supplémentaires
PLAN_GROUP_LIST=""
PLAN_REPO_REALNAME=""
PLAN_REPO_HOSTNAME=""

# Pré-vérifications
checkAction
checkIfRepoOrGroup

# Cas où on traite 1 repo seulement :
if [ ! -z "$PLAN_REPO_NAME" ];then
	# Si $PLAN_ACTION = update alors on met à jour le repo
	if [ "$PLAN_ACTION" == "update" ];then
		if [ "$OS_FAMILY" == "Redhat" ];then echo "Mise à jour du repo ${PLAN_REPO_NAME}";fi
		if [ "$OS_FAMILY" == "Debian" ];then echo "Mise à jour de la section ${PLAN_REPO_SECTION} du repo ${PLAN_REPO_NAME} (distribution ${PLAN_REPO_DIST})";fi
		if [ "$OS_FAMILY" == "Redhat" ];then
			updateRepo --gpg-check ${PLAN_GPG_CHECK} --gpg-resign ${PLAN_GPG_RESIGN} --repo-name ${PLAN_REPO_NAME} --repo-real-name ${PLAN_REPO_REALNAME}
		fi
		if [ "$OS_FAMILY" == "Debian" ];then
			updateRepo --gpg-check ${PLAN_GPG_CHECK} --repo-name ${PLAN_REPO_NAME} --repo-host-name ${PLAN_REPO_HOSTNAME} --repo-dist ${PLAN_REPO_DIST} --repo-section ${PLAN_REPO_SECTION}
		fi
	fi

	# Si $PLAN_ACTION contient -> alors il s'agit d'un changement d'env
	if [[ "$PLAN_ACTION" =~ "->" ]];then
		PLAN_REPO_ENV=$(echo $PLAN_ACTION | awk -F '->' '{print $1}')
		PLAN_REPO_NEXTENV=$(echo $PLAN_ACTION | awk -F '->' '{print $2}')
		if [ -z "$PLAN_REPO_ENV" ] || [ -z "$PLAN_REPO_NEXTENV" ];then
			(( PLAN_ERROR++ ))
			MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (EP04) : Environnement(s) non défini(s)"
			plan_exit
		fi
		
		if [ "$OS_FAMILY" == "Redhat" ];then echo "Changement d'environnement (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) du repo ${PLAN_REPO_NAME}";fi
		if [ "$OS_FAMILY" == "Debian" ];then echo "Changement d'environnement (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) de la section ${PLAN_REPO_SECTION} du repo ${PLAN_REPO_NAME} (distribution ${PLAN_REPO_DIST})";fi
		if [ "$OS_FAMILY" == "Redhat" ];then
			changeEnv --repo-name ${PLAN_REPO_NAME} --repo-env ${PLAN_REPO_ENV} --repo-new-env ${PLAN_REPO_NEXTENV}
		fi
		if [ "$OS_FAMILY" == "Debian" ];then
			changeEnv --repo-name ${PLAN_REPO_NAME} --repo-dist ${PLAN_REPO_DIST} --repo-section ${PLAN_REPO_SECTION} --repo-env ${PLAN_REPO_ENV} --repo-new-env ${PLAN_REPO_NEXTENV}
		fi
	fi
fi

# Cas où on traite un groupe de repos/sections :
if ([ ! -z "$PLAN_GROUP" ] && [ ! -z "$PLAN_GROUP_LIST" ]);then
	for LINE in $(echo "$PLAN_GROUP_LIST");do
		# Pour chaque ligne on récupère les infos du repo/section
		if [ "$OS_FAMILY" == "Redhat" ];then 
			GROUP_REPO_NAME=$(echo $LINE | awk -F ',' '{print $1}' | cut -d'=' -f2 | sed 's/"//g')
			GROUP_REPO_REALNAME=$(grep "^Name=\"${GROUP_REPO_NAME}\"" $REPOS_LIST | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
		fi

		if [ "$OS_FAMILY" == "Debian" ];then
			GROUP_REPO_NAME=$(echo $LINE | awk -F ',' '{print $1}' | cut -d'=' -f2 | sed 's/"//g')
			GROUP_REPO_HOSTNAME=$(grep "^Name=\"${GROUP_REPO_NAME}\"" $REPOS_LIST | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
			GROUP_REPO_DIST=$(echo $LINE | awk -F ',' '{print $3}' | cut -d'=' -f2 | sed 's/"//g')
			GROUP_REPO_SECTION=$(echo $LINE | awk -F ',' '{print $4}' | cut -d'=' -f2 | sed 's/"//g')
		fi

		# Si $PLAN_ACTION = update alors on met à jour les repos du groupe
		if [ "$PLAN_ACTION" == "update" ];then
			# Exécution 
			if [ "$OS_FAMILY" == "Redhat" ];then echo "Mise à jour du repo ${GROUP_REPO_NAME}";fi
			if [ "$OS_FAMILY" == "Debian" ];then echo "Mise à jour de la section ${GROUP_REPO_SECTION} du repo ${GROUP_REPO_NAME} (distribution ${GROUP_REPO_DIST})";fi
			if [ "$OS_FAMILY" == "Redhat" ];then
				updateRepo --gpg-check ${PLAN_GPG_CHECK} --gpg-resign ${PLAN_GPG_RESIGN} --repo-name ${GROUP_REPO_NAME} --repo-real-name ${GROUP_REPO_REALNAME}
			fi
			if [ "$OS_FAMILY" == "Debian" ];then
				updateRepo --gpg-check ${PLAN_GPG_CHECK} --repo-name ${GROUP_REPO_NAME} --repo-host-name ${GROUP_REPO_HOSTNAME} --repo-dist ${GROUP_REPO_DIST} --repo-section ${GROUP_REPO_SECTION}
			fi
		fi

		# Si $PLAN_ACTION contient -> alors il s'agit d'un changement d'env
		if [[ "$PLAN_ACTION" =~ "->" ]];then
			PLAN_REPO_ENV=$(echo $PLAN_ACTION | awk -F '->' '{print $1}')
			PLAN_REPO_NEXTENV=$(echo $PLAN_ACTION | awk -F '->' '{print $2}')
			if [ -z "$PLAN_REPO_ENV" ] || [ -z "$PLAN_REPO_NEXTENV" ];then
				(( PLAN_ERROR++ ))
				MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (EP04) : Environnement(s) non défini(s)"
				plan_exit
			fi
			# toto
			# vérifier si le repo à traiter possède un environnement correspondant à ${PLAN_REPO_ENV} :


			if [ "$OS_FAMILY" == "Redhat" ];then echo -e "\n\nChangement d'env (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) du repo ${GROUP_REPO_NAME}";fi
			if [ "$OS_FAMILY" == "Debian" ];then echo -e "\n\nChangement d'env (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) de la section ${GROUP_REPO_SECTION} du repo ${GROUP_REPO_NAME} (distribution ${GROUP_REPO_DIST})";fi
			
			if [ "$OS_FAMILY" == "Redhat" ];then
				changeEnv --repo-name ${GROUP_REPO_NAME} --repo-env ${PLAN_REPO_ENV} --repo-new-env ${PLAN_REPO_NEXTENV}
			fi
			if [ "$OS_FAMILY" == "Debian" ];then
				changeEnv --repo-name ${GROUP_REPO_NAME} --repo-dist ${GROUP_REPO_DIST} --repo-section ${GROUP_REPO_SECTION} --repo-env ${PLAN_REPO_ENV} --repo-new-env ${PLAN_REPO_NEXTENV}
			fi
		fi
	done
fi
# On quitte
plan_exit
}


# Envoi des rappels de planifications X jours avant (défini lorsqu'on ajoute une planification)
sendReminders() {
# Récupération de la liste de toutes les planifications dans le fichier de conf ([Plan-1], [Plan-2], ...)
LISTE_DE_PLANIFICATIONS=$(grep "\[Plan-.*\]" "$PLAN_CONF")

for PLANIFICATION in $(echo "$LISTE_DE_PLANIFICATIONS"); do
    # On supprime les crochets [ ] du nom car on va devoir les échapper
    PLANIFICATION=$(echo "$PLANIFICATION" | sed 's/\[//g' | sed 's/\]//g')
    # Récupération de toute la conf de la planification qu'on traite
    PLAN_DATE=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^Date=" | cut -d'=' -f2 | sed 's/"//g')
	PLAN_TIME=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^Time=" | cut -d'=' -f2 | sed 's/"//g')
    PLAN_ACTION=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^Action=" | cut -d'=' -f2 | sed 's/"//g')
    PLAN_REPO_NAME=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^Repo=" | cut -d'=' -f2 | sed 's/"//g')
    PLAN_REPO_DIST=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^Dist=" | cut -d'=' -f2 | sed 's/"//g')
    PLAN_REPO_SECTION=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^Section=" | cut -d'=' -f2 | sed 's/"//g')
    PLAN_GROUP=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^Group=" | cut -d'=' -f2 | sed 's/"//g')
    PLAN_GPG_CHECK=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^GpgCheck=" | cut -d'=' -f2 | sed 's/"//g')
    PLAN_GPG_RESIGN=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^GpgResign=" | cut -d'=' -f2 | sed 's/"//g')
    PLAN_REMINDERS=$(sed -n "/\[${PLANIFICATION}\]/,/\[/p" "$PLAN_CONF" | grep "^Reminder=" | cut -d'=' -f2 | sed 's/"//g')

	# Pré-vérifications
	checkAction; 			if [ "$PLAN_ERROR" -ne "0" ];then plan_exit;fi
	checkIfRepoOrGroup; 	if [ "$PLAN_ERROR" -ne "0" ];then plan_exit;fi

    # Traitement des rappels
    # Envoi des mails de rappels si nécessaire. Les rappels sont définis en nombre de jours à l'avance (ex 7days = rappel 7 jours à l'avance) et sont séparés par des virgules. 
	# Du coup on défini le séparateur de champ IFS comme étant une virgule. Mais d'abord on sauvegarde le séparateur par défaut dans $old_IFS :
    old_IFS=$IFS
	IFS=,
	for REMINDER in $PLAN_REMINDERS;do
		# On formatte le rappel car celui-ci contient une chaine non désirée 'day' car un rappel est toujours noté sous la forme : 1day,2days,etc
		#REMINDER=$(echo ${REMINDER} | sed 's/day*//g')
        # Si la date d'aujourd'hui correspond à une des dates de rappel définie (par ex nous sommes 7j avant le traitement et il y a justement une demande de rappel 7j avant), alors on récupère les repos concernés et on forge le message de rappel avec l'action associée (update ou changement d'env)
		if [ $(date -d "$PLAN_DATE today - $REMINDER" +"%Y-%m-%d") == "$DATE_AMJ" ];then
			# TEST OK :
			# Cas où la planif à rappeler ne concerne qu'un seul repo/section
			if [ ! -z "$PLAN_REPO_NAME" ];then
				# Cas où l'action prévue est une mise à jour
				if [ "$PLAN_ACTION" == "update" ];then
					if [ "$OS_FAMILY" == "Redhat" ];then
						MSG_REMINDER="${MSG_REMINDER}\nMise à jour du repo ${PLAN_REPO_NAME} (environnement ${DEFAULT_ENV}) prévue le ${PLAN_DATE} à ${PLAN_TIME}"
					fi
					if [ "$OS_FAMILY" == "Debian" ];then
						MSG_REMINDER="${MSG_REMINDER}\nMise à jour de la section ${PLAN_REPO_SECTION} du repo ${PLAN_REPO_NAME} (distribution ${PLAN_REPO_DIST}) (environnement ${DEFAULT_ENV}) prévue le ${PLAN_DATE} à ${PLAN_TIME}"
					fi
				fi
				# Cas où l'action prévue est un changement d'env
				if [[ "$PLAN_ACTION" =~ "->" ]];then
					PLAN_REPO_ENV=$(echo $PLAN_ACTION | awk -F '->' '{print $1}')
					PLAN_REPO_NEXTENV=$(echo $PLAN_ACTION | awk -F '->' '{print $2}')
					if [ -z "$PLAN_REPO_ENV" ] || [ -z "$PLAN_REPO_NEXTENV" ];then
						(( PLAN_ERROR++ ))
						MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (RP01) : Environnement(s) non défini(s)" # toto : c'est un rappel alors ça ne peut pas être MSG_PLAN_ERROR
						continue
					fi

					if [ "$OS_FAMILY" == "Redhat" ];then
						MSG_REMINDER="${MSG_REMINDER}\nChangement d'environnement (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) du repo ${PLAN_REPO_NAME} prévu le ${PLAN_DATE} à ${PLAN_TIME}"
					fi
					if [ "$OS_FAMILY" == "Debian" ];then
						MSG_REMINDER="${MSG_REMINDER}\nChangement d'environnement (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) de la section ${PLAN_REPO_SECTION} du repo ${PLAN_REPO_NAME} (distribution ${PLAN_REPO_DIST}) prévu le ${PLAN_DATE} à ${PLAN_TIME}"
					fi
				fi
			fi

			# TEST OK : 
			# Cas où la planif à rappeler concerne un groupe de repo
			if ([ ! -z "$PLAN_GROUP" ] && [ ! -z "$PLAN_GROUP_LIST" ]);then
				# Pour récupérer correctement chaque ligne du groupe $PLAN_GROUP On redéfini le séparateur par le séparateur par défaut et non plus par une virgule
				# On redéfinera la virgule après la fin de la boucle for
				IFS=$old_IFS
				for LINE in $(echo "$PLAN_GROUP_LIST");do
					# Pour chaque ligne on récupère les infos du repo/section
					if [ "$OS_FAMILY" == "Redhat" ];then 
						GROUP_REPO_NAME=$(echo $LINE | awk -F ',' '{print $1}' | cut -d'=' -f2 | sed 's/"//g')
						GROUP_REPO_REALNAME=$(grep "^Name=\"${GROUP_REPO_NAME}\"" $REPOS_LIST | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
					fi

					if [ "$OS_FAMILY" == "Debian" ];then
						GROUP_REPO_NAME=$(echo $LINE | awk -F ',' '{print $1}' | cut -d'=' -f2 | sed 's/"//g')
						GROUP_REPO_DIST=$(echo $LINE | awk -F ',' '{print $2}' | cut -d'=' -f2 | sed 's/"//g')
						GROUP_REPO_SECTION=$(echo $LINE | awk -F ',' '{print $3}' | cut -d'=' -f2 | sed 's/"//g')
					fi

					# Cas où l'action prévue est une mise à jour
					if [ "$PLAN_ACTION" == "update" ];then
						if [ "$OS_FAMILY" == "Redhat" ];then
							MSG_REMINDER="${MSG_REMINDER}\nMise à jour du repo ${GROUP_REPO_NAME} (environnement ${DEFAULT_ENV}) prévue le ${PLAN_DATE} à ${PLAN_TIME}"
						fi
						if [ "$OS_FAMILY" == "Debian" ];then
							MSG_REMINDER="${MSG_REMINDER}\nMise à jour de la section ${GROUP_REPO_SECTION} du repo ${GROUP_REPO_NAME} (distribution ${GROUP_REPO_DIST}) (environnement ${DEFAULT_ENV}) prévue le ${PLAN_DATE} à ${PLAN_TIME}"
						fi
					fi

					# Cas où l'action prévue est un changement d'env
					if [[ "$PLAN_ACTION" =~ "->" ]];then
						PLAN_REPO_ENV=$(echo $PLAN_ACTION | awk -F '->' '{print $1}')
						PLAN_REPO_NEXTENV=$(echo $PLAN_ACTION | awk -F '->' '{print $2}')
						if [ -z "$PLAN_REPO_ENV" ] || [ -z "$PLAN_REPO_NEXTENV" ];then
							(( PLAN_ERROR++ ))
							MSG_PLAN_ERROR="${MSG_PLAN_ERROR}\nErreur (RP01) : Environnement(s) non défini(s)" # toto : c'est un rappel alors ça ne peut pas être MSG_PLAN_ERROR
							continue
						fi
						if [ "$OS_FAMILY" == "Redhat" ];then
							MSG_REMINDER="${MSG_REMINDER}\nChangement d'environnement (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) du repo ${GROUP_REPO_NAME} prévu le ${PLAN_DATE} à ${PLAN_TIME}"
						fi
						if [ "$OS_FAMILY" == "Debian" ];then
							MSG_REMINDER="${MSG_REMINDER}\nChangement d'environnement (${PLAN_REPO_ENV} -> ${PLAN_REPO_NEXTENV}) de la section ${GROUP_REPO_SECTION} du repo ${GROUP_REPO_NAME} (distribution ${GROUP_REPO_DIST}) prévu le ${PLAN_DATE} à ${PLAN_TIME}"
						fi
					fi
				done
				# On rétabli le séparateur comme étant une virgule pour pouvoir continuer à traiter les rappels suivants (séparés par une virgule)
				IFS=, 
			fi
		fi		
	done
	IFS=$old_IFS
done
rappel_mail
}

plan_exit() {
# Si des erreurs on été rencontrées, on affiche le message d'erreur
if [ "$PLAN_ERROR" -ne "0" ];then
	# Suppression des lignes vides dans le message d'erreur si il y en a
	MSG_PLAN_ERROR=$(echo -e "$MSG_PLAN_ERROR" | sed '/^$/d')
	echo -e "$MSG_PLAN_ERROR"
fi

# Ajout de la tâche planifiée dans le fichier de log avec son état (OK ou en erreur).
# On génère un nouvel ID pour cette planification (dernière planification du fichier de log +1). En effet les ID des planifications dans le fichier de log
# doivent être uniques et ce n'est pas grave si ce n'est pas le même ID que la planification d'origine dans planifications.conf
# Récupération du dernier ID dans le fichier de log :
PLAN_LOG_ID=$(grep "\[Plan-.*\]" $PLAN_LOG | tail -n1 | sed 's/\[Plan\-//g; s/\]//g')
if [ -z "$PLAN_LOG_ID" ];then
	PLAN_LOG_ID="1"			# Si il n'y avait aucune planification dans le fichier de log alors la première portera l'ID n°1
else
	(( PLAN_LOG_ID++ ))		# Sinon on incrémente l'ID récupéré
fi

# On crée un fichier temporaire dans lequel on met toutes les infos de la planification exécutée
echo "[Plan-${PLAN_LOG_ID}]" > /tmp/repomanager_newplanlog_${PLAN_LOG_ID}.tmp
# On ajoute à la suite l'état de la planification (OK ou en Erreur)
if [ "$PLAN_ERROR" -eq "0" ];then
	echo "Status=\"OK\"" >> /tmp/repomanager_newplanlog_${PLAN_LOG_ID}.tmp
else
	echo "Status=\"Error\"" >> /tmp/repomanager_newplanlog_${PLAN_LOG_ID}.tmp
	echo "Error=\"$MSG_PLAN_ERROR\"" >> /tmp/repomanager_newplanlog_${PLAN_LOG_ID}.tmp
fi
# On récupère les paramètres de la planification exécutée :
sed -n "/\[Plan-${PLAN_ID}\]/,/\[/p" "$PLAN_CONF" | grep -v "Plan-" >> /tmp/repomanager_newplanlog_${PLAN_LOG_ID}.tmp

# Enfin on ajoute les données de la planification dans le fichier de log :
cat /tmp/repomanager_newplanlog_${PLAN_LOG_ID}.tmp >> $PLAN_LOG
echo "" >> $PLAN_LOG # Ajout d'un saut le ligne après chaque planification renseignée dans le fichier de log

# Puis suppression de la tâche planifiée dans planifications.conf
sed -i "/\[Plan-${PLAN_ID}\]/,/\[/d" "$PLAN_CONF"

# On quitte repomanager, la fonction clean_exit se chargera d'envoyer un mail d'erreur si il y a eu des erreurs
clean_exit
}